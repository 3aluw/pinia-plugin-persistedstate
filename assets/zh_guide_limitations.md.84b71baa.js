import{_ as s,c as a,o as e,a as n}from"./app.884a5220.js";const u=JSON.parse('{"title":"局限性","description":"","frontmatter":{},"headers":[{"level":2,"title":"引用不会被持久化","slug":"引用不会被持久化","link":"#引用不会被持久化","children":[]},{"level":2,"title":"基本类型之外的将不会被持久化","slug":"基本类型之外的将不会被持久化","link":"#基本类型之外的将不会被持久化","children":[]},{"level":2,"title":"存储必须是同步的","slug":"存储必须是同步的","link":"#存储必须是同步的","children":[]}],"relativePath":"zh/guide/limitations.md","lastUpdated":1675527500000}'),o={name:"zh/guide/limitations.md"},l=n(`<h1 id="局限性" tabindex="-1">局限性 <a class="header-anchor" href="#局限性" aria-hidden="true">#</a></h1><p>虽然该插件具有很大的灵活性以及丰富的功能，但也有一些限制需要考虑。</p><h2 id="引用不会被持久化" tabindex="-1">引用不会被持久化 <a class="header-anchor" href="#引用不会被持久化" aria-hidden="true">#</a></h2><p>由于数据将会被序列化，因此引用在刷新时将会丢失。 我们来看看下面这个例子：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#CB7676;">const </span><span style="color:#BD976A;">a</span><span style="color:#CB7676;"> = </span><span style="color:#666666;">{</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#4C9A91;">1</span><span style="color:#666666;">: </span><span style="color:#C98A7D99;">&#39;</span><span style="color:#C98A7D;">one</span><span style="color:#C98A7D99;">&#39;</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#4C9A91;">2</span><span style="color:#666666;">: </span><span style="color:#C98A7D99;">&#39;</span><span style="color:#C98A7D;">two</span><span style="color:#C98A7D99;">&#39;</span><span style="color:#666666;">,</span></span>
<span class="line"><span style="color:#666666;">  </span><span style="color:#758575DD;">// ...</span></span>
<span class="line"><span style="color:#666666;">}</span></span>
<span class="line"><span style="color:#CB7676;">const </span><span style="color:#BD976A;">b</span><span style="color:#CB7676;"> = </span><span style="color:#BD976A;">a</span></span>
<span class="line"></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#AB5959;">const </span><span style="color:#B07D48;">a</span><span style="color:#AB5959;"> = </span><span style="color:#999999;">{</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#2F798A;">1</span><span style="color:#999999;">: </span><span style="color:#B5695999;">&#39;</span><span style="color:#B56959;">one</span><span style="color:#B5695999;">&#39;</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#2F798A;">2</span><span style="color:#999999;">: </span><span style="color:#B5695999;">&#39;</span><span style="color:#B56959;">two</span><span style="color:#B5695999;">&#39;</span><span style="color:#999999;">,</span></span>
<span class="line"><span style="color:#999999;">  </span><span style="color:#A0ADA0;">// ...</span></span>
<span class="line"><span style="color:#999999;">}</span></span>
<span class="line"><span style="color:#AB5959;">const </span><span style="color:#B07D48;">b</span><span style="color:#AB5959;"> = </span><span style="color:#B07D48;">a</span></span>
<span class="line"></span></code></pre></div><p>在序列化之前， <code>a</code> 和 <code>b</code> 指向了同一个对象：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#BD976A;">a</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">===</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">b</span><span style="color:#DBD7CAEE;"> </span><span style="color:#758575DD;">// -&gt; true</span></span>
<span class="line"></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#B07D48;">a</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">===</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">b</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">// -&gt; true</span></span>
<span class="line"></span></code></pre></div><p>在反序列化之后, <code>a</code> 和 <code>b</code> 是有着相同内容的不同对象：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki vitesse-dark vp-code-dark"><code><span class="line"><span style="color:#BD976A;">a</span><span style="color:#DBD7CAEE;"> </span><span style="color:#CB7676;">===</span><span style="color:#DBD7CAEE;"> </span><span style="color:#BD976A;">b</span><span style="color:#DBD7CAEE;"> </span><span style="color:#758575DD;">// -&gt; false</span></span>
<span class="line"></span></code></pre><pre class="shiki vitesse-light vp-code-light"><code><span class="line"><span style="color:#B07D48;">a</span><span style="color:#393A34;"> </span><span style="color:#AB5959;">===</span><span style="color:#393A34;"> </span><span style="color:#B07D48;">b</span><span style="color:#393A34;"> </span><span style="color:#A0ADA0;">// -&gt; false</span></span>
<span class="line"></span></code></pre></div><p>因此，<code>a</code> 和 <code>b</code> 之间的联系将会丢失。</p><div class="tip custom-block"><p class="custom-block-title">解决方法</p><p>为了解决这个问题，你可以采取避免 <code>a</code> 或 <code>b</code> 被持久化的方法(使用 <a href="/pinia-plugin-persistedstate/zh/guide/config.html#paths"><code>paths</code></a> 选项)，并使用 <a href="/pinia-plugin-persistedstate/zh/guide/config.html#afterrestore"><code>afterRestore</code></a> 钩子在恢复数据后重新存储它们。这样 <code>a</code> 和 <code>b</code> 就又会有着相同的引用，两者之间的联系就恢复了。</p></div><h2 id="基本类型之外的将不会被持久化" tabindex="-1">基本类型之外的将不会被持久化 <a class="header-anchor" href="#基本类型之外的将不会被持久化" aria-hidden="true">#</a></h2><p>由于数据将会被序列化，因此非基本类型（如 <code>Date</code>）不会以 <code>Date</code> 对象形式存储，而是作为 <code>string</code>。</p><div class="tip custom-block"><p class="custom-block-title">解决方法</p><p>为了解决这个问题，你可以：</p><ul><li>使用 <a href="/pinia-plugin-persistedstate/zh/guide/config.html#afterrestore"><code>afterRestore</code></a> 钩子在恢复数据后重新创建对象。</li><li>使用自定义的 <a href="/pinia-plugin-persistedstate/zh/guide/config.html#serializer"><code>serializer</code></a> 来配置你想要持久化的数据类型。</li></ul></div><h2 id="存储必须是同步的" tabindex="-1">存储必须是同步的 <a class="header-anchor" href="#存储必须是同步的" aria-hidden="true">#</a></h2><p>当提供自定义 <a href="/pinia-plugin-persistedstate/zh/guide/config.html#storage"><code>storage</code></a> 时，其方法必须是同步的，这是因为 Pinia 的状态订阅（<a href="https://pinia.vuejs.org/zh/core-concepts/state.html#subscribing-to-the-state" target="_blank" rel="noreferrer"><code>$subscribe</code></a>）是同步的(与 mutations 一致)。</p><div class="tip custom-block"><p class="custom-block-title">解决方法</p><p>如果要添加异步行为（例如使用 async storages），你可以尝试 <a href="https://pinia.vuejs.org/zh/core-concepts/actions.html#subscribing-to-actions" target="_blank" rel="noreferrer">订阅 action (<code>$onAction</code>)</a>。</p></div>`,17),p=[l];function t(c,r,i,d,y,h){return e(),a("div",null,p)}const A=s(o,[["render",t]]);export{u as __pageData,A as default};
