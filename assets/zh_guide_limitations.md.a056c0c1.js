import{_ as s,c as a,o as e,a as o}from"./app.1560828f.js";const u=JSON.parse('{"title":"局限性","description":"","frontmatter":{},"headers":[{"level":2,"title":"引用不会被持久化","slug":"引用不会被持久化","link":"#引用不会被持久化","children":[]},{"level":2,"title":"基本类型之外的将不会被持久化","slug":"基本类型之外的将不会被持久化","link":"#基本类型之外的将不会被持久化","children":[]},{"level":2,"title":"存储必须是同步的","slug":"存储必须是同步的","link":"#存储必须是同步的","children":[]}],"relativePath":"zh/guide/limitations.md","lastUpdated":1676562677000}'),t={name:"zh/guide/limitations.md"},n=o(`<h1 id="局限性" tabindex="-1">局限性 <a class="header-anchor" href="#局限性" aria-hidden="true">#</a></h1><p>虽然该插件具有很大的灵活性以及丰富的功能，但也有一些限制需要考虑。</p><h2 id="引用不会被持久化" tabindex="-1">引用不会被持久化 <a class="header-anchor" href="#引用不会被持久化" aria-hidden="true">#</a></h2><p>由于数据将会被序列化，因此引用在刷新时将会丢失。 我们来看看下面这个例子：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">const</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">a</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  </span><span style="color:var(--shiki-token-constant);">1</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&#39;one&#39;</span><span style="color:var(--shiki-token-punctuation);">,</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  </span><span style="color:var(--shiki-token-constant);">2</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&#39;two&#39;</span><span style="color:var(--shiki-token-punctuation);">,</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  </span><span style="color:var(--shiki-token-comment);">// ...</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">}</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">const</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">b</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> a</span></span>
<span class="line"></span></code></pre></div><p>在序列化之前， <code>a</code> 和 <code>b</code> 指向了同一个对象：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">a </span><span style="color:var(--shiki-token-keyword);">===</span><span style="color:var(--shiki-color-text);"> b </span><span style="color:var(--shiki-token-comment);">// -&gt; true</span></span>
<span class="line"></span></code></pre></div><p>在反序列化之后, <code>a</code> 和 <code>b</code> 是有着相同内容的不同对象：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">a </span><span style="color:var(--shiki-token-keyword);">===</span><span style="color:var(--shiki-color-text);"> b </span><span style="color:var(--shiki-token-comment);">// -&gt; false</span></span>
<span class="line"></span></code></pre></div><p>因此，<code>a</code> 和 <code>b</code> 之间的联系将会丢失。</p><div class="tip custom-block"><p class="custom-block-title">解决方法</p><p>为了解决这个问题，你可以采取避免 <code>a</code> 或 <code>b</code> 被持久化的方法(使用 <a href="/pinia-plugin-persistedstate/zh/guide/config.html#paths"><code>paths</code></a> 选项)，并使用 <a href="/pinia-plugin-persistedstate/zh/guide/config.html#afterrestore"><code>afterRestore</code></a> 钩子在恢复数据后重新存储它们。这样 <code>a</code> 和 <code>b</code> 就又会有着相同的引用，两者之间的联系就恢复了。</p></div><h2 id="基本类型之外的将不会被持久化" tabindex="-1">基本类型之外的将不会被持久化 <a class="header-anchor" href="#基本类型之外的将不会被持久化" aria-hidden="true">#</a></h2><p>由于数据将会被序列化，因此非基本类型（如 <code>Date</code>）不会以 <code>Date</code> 对象形式存储，而是作为 <code>string</code>。</p><div class="tip custom-block"><p class="custom-block-title">解决方法</p><p>为了解决这个问题，你可以：</p><ul><li>使用 <a href="/pinia-plugin-persistedstate/zh/guide/config.html#afterrestore"><code>afterRestore</code></a> 钩子在恢复数据后重新创建对象。</li><li>使用自定义的 <a href="/pinia-plugin-persistedstate/zh/guide/config.html#serializer"><code>serializer</code></a> 来配置你想要持久化的数据类型。</li></ul></div><h2 id="存储必须是同步的" tabindex="-1">存储必须是同步的 <a class="header-anchor" href="#存储必须是同步的" aria-hidden="true">#</a></h2><p>当提供自定义 <a href="/pinia-plugin-persistedstate/zh/guide/config.html#storage"><code>storage</code></a> 时，其方法必须是同步的，这是因为 Pinia 的状态订阅（<a href="https://pinia.vuejs.org/zh/core-concepts/state.html#subscribing-to-the-state" target="_blank" rel="noreferrer"><code>$subscribe</code></a>）是同步的(与 mutations 一致)。</p><div class="tip custom-block"><p class="custom-block-title">解决方法</p><p>如果要添加异步行为（例如使用 async storages），你可以尝试 <a href="https://pinia.vuejs.org/zh/core-concepts/actions.html#subscribing-to-actions" target="_blank" rel="noreferrer">订阅 action (<code>$onAction</code>)</a>。</p></div>`,17),i=[n];function l(c,r,p,d,h,k){return e(),a("div",null,i)}const y=s(t,[["render",l]]);export{u as __pageData,y as default};
